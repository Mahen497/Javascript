

## üìù Function Declaration

```js
function greet() {
  console.log("Hello");
}
greet(); // ‚úÖ
```

* Named function
* Can be used **before or after** it‚Äôs defined ‚úÖ

---

### üìù Function Expression

```js
const greet = function() {
  console.log("Hello");
};
greet(); // ‚úÖ
```

* Stored in a **variable**
* Can be called **only after** it‚Äôs defined ‚ö°
* Can be **anonymous (no name)**

---

## ‚ö° Key Difference

| Declaration                 | Expression       |
| --------------------------- | ---------------- |
| Named function üìõ           | In a variable üì¶ |
| Hoisted (can call before) ‚úÖ | Not hoisted ‚ö°    |

---

## üß† Memory Trick

**Expression = inside a variable üí°**
**Declaration = normal named function üìõ**

Say in your head:

> ‚Äú**Expression is like storing a function in a box üì¶
> I open the box (variable) to run it.**‚Äù

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## üìù IIFE (Immediately Invoked Function Expression)** in JavaScript. ‚ö°

---

### üìù Code

```js
(function greet() {
  alert("Hello World");
})();
```
---

### ‚ö° What it does

* The function is **defined** and then **immediately called**
* Runs **as soon as the browser reads it**

---

### üìå Why the brackets

* `(function greet(){...})` ‚Üí makes it a **function expression**
* `();` ‚Üí **calls** the function immediately

---

### üí° Use Cases

* Run code only once
* Avoid polluting global variables (keeps variables private)

---

## üß† Memory Trick

> **IIFE = Define + Run instantly üöÄ**

Say in your head:

> **‚ÄúWrap it ( ) then run it ( )‚Äù** üåÄ

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## üìå WHY use IIFE

* To **run code immediately** without calling it later
* To **avoid global variable pollution**
* To **create a private scope** for variables

---

## üìç WHERE to use IIFE

* When you want **initial setup code** to run once (like settings, config, loading data)
* Inside scripts where you want to **keep variables hidden** from other scripts
* In **modules or libraries** to prevent variable name conflicts

---

## ‚è∞ WHEN to use IIFE

* When you need something to:

  * run **immediately once**
  * but you **don‚Äôt need it again**
* Example: on **page load**, set theme, initialize data, or start timers

---

## üí° Real-life Analogy

Imagine you open a **sealed lunch box üç± (IIFE)**:

* You **open ‚Üí eat ‚Üí throw the box**
* Nothing from inside goes outside
* You can‚Äôt access it again later

This is what an IIFE does ‚Äî
**runs once ‚Üí done ‚Üí disappears (keeps things private).**

---

## üß† Memory Trick

> **IIFE = One-time secret mission ü§´üöÄ**

Say in your head:

> ‚ÄúDo the job once and vanish.‚Äù

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Here‚Äôs a **short and clear summary** of your content on **JavaScript Function Expressions**:

---

### **JavaScript Function Expressions ‚Äì Summary**

1. **Definition:**
   A function expression defines a function and stores it in a variable. It can be **anonymous** (no name) or **named**.

   ```javascript
   // Anonymous
   const sum = function(a, b) { return a + b; };

   // Named
   const sum = function addNumbers(a, b) { return a + b; };
   ```

   * **Invoke using the variable**, not the function name (for named expressions).

---

2. **Immediately Invoked Function Expression (IIFE):**
   A function expression can run immediately after defining:

   ```javascript
   (function greet() {
       alert("Hello World");
   })();
   ```

---

3. **Return Statement:**
   Function expressions can return values like normal functions:

   ```javascript
   const mul = function(a, b) { return a * b; };
   let result = mul(4, 5); // 20
   ```

---

4. **Use as a Value:**
   The returned value from a function expression can be used in expressions:

   ```javascript
   const num = function() { return 2; };
   let result = num() * 3; // 6
   ```

---

5. **Nested Function Expressions:**
   You can define a function inside another function and call it:

   ```javascript
   const num = function() {
       const decimal = function() { return 5; };
       return decimal(); 
   };
   console.log(num()); // 5
   ```

---

‚úÖ **Key Points to Remember:**

* Function expressions can be **anonymous or named**.
* Use variable to **invoke the function**.
* Can be used as **IIFE, value, or nested function**.
* Helps in **keeping variables private** and avoiding global scope pollution.

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Great question! üëá
Let‚Äôs quickly understand what **`eval`** is ‚Äî because I mentioned it for comparison with `Function()`.

---

## ‚ö†Ô∏è What is `eval` in JavaScript

* `eval()` is a **built-in JavaScript function**.
* It takes a **string of JavaScript code** and **executes it immediately**.

---

### üìå Example

```javascript
const code = "2 + 3";
console.log(eval(code));  // 5
```

```javascript
eval("var x = 10; console.log(x);"); // 10
```

---

### ‚ö†Ô∏è Why it's risky

* `eval()` can **run any code**, even malicious code from user input.
* It makes debugging and performance worse.
* That‚Äôs why it‚Äôs considered **dangerous** and should be **avoided in real projects**.

---

### üìå Relation with `Function()` constructor

* Both `eval()` and `new Function()` **convert strings into executable code** at runtime.
* `new Function()` is **safer than `eval`** (it runs in global scope and has no access to local scope), but **still risky**.

---

### üß† Memory trick

> `eval("...")` ‚Üí **Evaluate this string now**
> `new Function("...")` ‚Üí **Make a new function from this string**

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

