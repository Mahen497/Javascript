

## ğŸ“ Function Declaration

```js
function greet() {
  console.log("Hello");
}
greet(); // âœ…
```

* Named function
* Can be used **before or after** itâ€™s defined âœ…

---

### ğŸ“ Function Expression

```js
const greet = function() {
  console.log("Hello");
};
greet(); // âœ…
```

* Stored in a **variable**
* Can be called **only after** itâ€™s defined âš¡
* Can be **anonymous (no name)**

---

## âš¡ Key Difference

| Declaration                 | Expression       |
| --------------------------- | ---------------- |
| Named function ğŸ“›           | In a variable ğŸ“¦ |
| Hoisted (can call before) âœ… | Not hoisted âš¡    |

---

## ğŸ§  Memory Trick

**Expression = inside a variable ğŸ’¡**
**Declaration = normal named function ğŸ“›**

Say in your head:

> â€œ**Expression is like storing a function in a box ğŸ“¦
> I open the box (variable) to run it.**â€

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## ğŸ“ IIFE (Immediately Invoked Function Expression)** in JavaScript. âš¡

---

### ğŸ“ Code

```js
(function greet() {
  alert("Hello World");
})();
```
---

### âš¡ What it does

* The function is **defined** and then **immediately called**
* Runs **as soon as the browser reads it**

---

### ğŸ“Œ Why the brackets

* `(function greet(){...})` â†’ makes it a **function expression**
* `();` â†’ **calls** the function immediately

---

### ğŸ’¡ Use Cases

* Run code only once
* Avoid polluting global variables (keeps variables private)

---

## ğŸ§  Memory Trick

> **IIFE = Define + Run instantly ğŸš€**

Say in your head:

> **â€œWrap it ( ) then run it ( )â€** ğŸŒ€

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## ğŸ“Œ WHY use IIFE

* To **run code immediately** without calling it later
* To **avoid global variable pollution**
* To **create a private scope** for variables

---

## ğŸ“ WHERE to use IIFE

* When you want **initial setup code** to run once (like settings, config, loading data)
* Inside scripts where you want to **keep variables hidden** from other scripts
* In **modules or libraries** to prevent variable name conflicts

---

## â° WHEN to use IIFE

* When you need something to:

  * run **immediately once**
  * but you **donâ€™t need it again**
* Example: on **page load**, set theme, initialize data, or start timers

---

## ğŸ’¡ Real-life Analogy

Imagine you open a **sealed lunch box ğŸ± (IIFE)**:

* You **open â†’ eat â†’ throw the box**
* Nothing from inside goes outside
* You canâ€™t access it again later

This is what an IIFE does â€”
**runs once â†’ done â†’ disappears (keeps things private).**

---

## ğŸ§  Memory Trick

> **IIFE = One-time secret mission ğŸ¤«ğŸš€**

Say in your head:

> â€œDo the job once and vanish.â€

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Hereâ€™s a **short and clear summary** of your content on **JavaScript Function Expressions**:

---

### **JavaScript Function Expressions â€“ Summary**

1. **Definition:**
   A function expression defines a function and stores it in a variable. It can be **anonymous** (no name) or **named**.

   ```javascript
   // Anonymous
   const sum = function(a, b) { return a + b; };

   // Named
   const sum = function addNumbers(a, b) { return a + b; };
   ```

   * **Invoke using the variable**, not the function name (for named expressions).

---

2. **Immediately Invoked Function Expression (IIFE):**
   A function expression can run immediately after defining:

   ```javascript
   (function greet() {
       alert("Hello World");
   })();
   ```

---

3. **Return Statement:**
   Function expressions can return values like normal functions:

   ```javascript
   const mul = function(a, b) { return a * b; };
   let result = mul(4, 5); // 20
   ```

---

4. **Use as a Value:**
   The returned value from a function expression can be used in expressions:

   ```javascript
   const num = function() { return 2; };
   let result = num() * 3; // 6
   ```

---

5. **Nested Function Expressions:**
   You can define a function inside another function and call it:

   ```javascript
   const num = function() {
       const decimal = function() { return 5; };
       return decimal(); 
   };
   console.log(num()); // 5
   ```

---

âœ… **Key Points to Remember:**

* Function expressions can be **anonymous or named**.
* Use variable to **invoke the function**.
* Can be used as **IIFE, value, or nested function**.
* Helps in **keeping variables private** and avoiding global scope pollution.

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Great question! ğŸ‘‡
Letâ€™s quickly understand what **`eval`** is â€” because I mentioned it for comparison with `Function()`.

---

## âš ï¸ What is `eval` in JavaScript

* `eval()` is a **built-in JavaScript function**.
* It takes a **string of JavaScript code** and **executes it immediately**.

---

### ğŸ“Œ Example

```javascript
const code = "2 + 3";
console.log(eval(code));  // 5
```

```javascript
eval("var x = 10; console.log(x);"); // 10
```

---

### âš ï¸ Why it's risky

* `eval()` can **run any code**, even malicious code from user input.
* It makes debugging and performance worse.
* Thatâ€™s why itâ€™s considered **dangerous** and should be **avoided in real projects**.

---

### ğŸ“Œ Relation with `Function()` constructor

* Both `eval()` and `new Function()` **convert strings into executable code** at runtime.
* `new Function()` is **safer than `eval`** (it runs in global scope and has no access to local scope), but **still risky**.

---

### ğŸ§  Memory trick

> `eval("...")` â†’ **Evaluate this string now**
> `new Function("...")` â†’ **Make a new function from this string**

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## ğŸ§  JavaScript `Function()` Constructor â€” Summary Notes

### ğŸ“Œ What it is

* `Function()` is a **built-in constructor** that creates **functions dynamically at runtime**.
* Syntax:

  ```js
  const fn = new Function(arg1, arg2, ..., functionBody);
  ```

  * All parameters are **strings**.
  * All arguments except the last are parameter names.
  * Last argument is the function body (code).

---

### ğŸ“Œ Key Points

* Functions created this way:

  * Always have **global scope** (not local).
  * Are created at **runtime (on the fly)**.
* Can be called **with or without `new`** keyword.
* âš ï¸ **Use with caution** â€” can cause **security issues** (like `eval`).

---

### ğŸ“Œ Examples

**With parameters**

```js
const mul = new Function("a", "b", "return a * b");
console.log(mul(5, 7));  // 35
```

**Without parameters**

```js
const sum = new Function("return 10 + 20");
console.log(sum()); // 30
```

**Return another function**

```js
const sayHello = new Function(
  "return function(name){ return `Hello, ${name}` }"
)();
console.log(sayHello("World")); // Hello, World
```

---

### ğŸ“Œ When to use

* When you need to **generate function code from strings at runtime** (very rare cases).
* Otherwise, prefer **normal function declarations / expressions** â€” they are **faster and safer**.

---

### âš¡ Memory Trick

> ğŸ§  `Function()` = like `eval` for functions
> ğŸ“ Use only when you must **build code from text dynamically**.

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Sure! ğŸ“
Hereâ€™s a **very short and clear summary** of **JavaScript Hoisting** for quick notes:

---

## âš¡ JavaScript Hoisting â€” Quick Summary

* **Hoisting:** JS moves **declarations** (not values) to the **top of their scope** before code runs.

---

### ğŸ§© Function Hoisting

* âœ… **Function Declarations** are hoisted
  â†’ You can call them before defining.

  ```js
  greet();
  function greet(){ console.log("Hi"); }
  ```

* âŒ **Function Expressions (let/const)** are **not hoisted**

  ```js
  greet(); // Error
  const greet = function(){};
  ```

---

### ğŸ“¦ Variable Hoisting

* âœ… **var** is hoisted â†’ value becomes `undefined` until assigned

  ```js
  console.log(x); // undefined
  var x = 10;
  ```

* âŒ **let / const** are **not hoisted**

  ```js
  console.log(x); // Error
  let x = 10;
  ```

---

### ğŸ§  Key Points to Remember

* Only **declarations** are hoisted, **not initializations**.
* Works **within the same scope** (function/block).
* Best practice: **Always declare before using.**

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

