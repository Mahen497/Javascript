

## üìù Function Declaration

```js
function greet() {
  console.log("Hello");
}
greet(); // ‚úÖ
```

* Named function
* Can be used **before or after** it‚Äôs defined ‚úÖ

---

### üìù Function Expression

```js
const greet = function() {
  console.log("Hello");
};
greet(); // ‚úÖ
```

* Stored in a **variable**
* Can be called **only after** it‚Äôs defined ‚ö°
* Can be **anonymous (no name)**

---

## ‚ö° Key Difference

| Declaration                 | Expression       |
| --------------------------- | ---------------- |
| Named function üìõ           | In a variable üì¶ |
| Hoisted (can call before) ‚úÖ | Not hoisted ‚ö°    |

---

## üß† Memory Trick

**Expression = inside a variable üí°**
**Declaration = normal named function üìõ**

Say in your head:

> ‚Äú**Expression is like storing a function in a box üì¶
> I open the box (variable) to run it.**‚Äù

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## üìù IIFE (Immediately Invoked Function Expression)** in JavaScript. ‚ö°

---

### üìù Code

```js
(function greet() {
  alert("Hello World");
})();
```
---

### ‚ö° What it does

* The function is **defined** and then **immediately called**
* Runs **as soon as the browser reads it**

---

### üìå Why the brackets

* `(function greet(){...})` ‚Üí makes it a **function expression**
* `();` ‚Üí **calls** the function immediately

---

### üí° Use Cases

* Run code only once
* Avoid polluting global variables (keeps variables private)

---

## üß† Memory Trick

> **IIFE = Define + Run instantly üöÄ**

Say in your head:

> **‚ÄúWrap it ( ) then run it ( )‚Äù** üåÄ

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## üìå WHY use IIFE

* To **run code immediately** without calling it later
* To **avoid global variable pollution**
* To **create a private scope** for variables

---

## üìç WHERE to use IIFE

* When you want **initial setup code** to run once (like settings, config, loading data)
* Inside scripts where you want to **keep variables hidden** from other scripts
* In **modules or libraries** to prevent variable name conflicts

---

## ‚è∞ WHEN to use IIFE

* When you need something to:

  * run **immediately once**
  * but you **don‚Äôt need it again**
* Example: on **page load**, set theme, initialize data, or start timers

---

## üí° Real-life Analogy

Imagine you open a **sealed lunch box üç± (IIFE)**:

* You **open ‚Üí eat ‚Üí throw the box**
* Nothing from inside goes outside
* You can‚Äôt access it again later

This is what an IIFE does ‚Äî
**runs once ‚Üí done ‚Üí disappears (keeps things private).**

---

## üß† Memory Trick

> **IIFE = One-time secret mission ü§´üöÄ**

Say in your head:

> ‚ÄúDo the job once and vanish.‚Äù

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Here‚Äôs a **short and clear summary** of your content on **JavaScript Function Expressions**:

---

### **JavaScript Function Expressions ‚Äì Summary**

1. **Definition:**
   A function expression defines a function and stores it in a variable. It can be **anonymous** (no name) or **named**.

   ```javascript
   // Anonymous
   const sum = function(a, b) { return a + b; };

   // Named
   const sum = function addNumbers(a, b) { return a + b; };
   ```

   * **Invoke using the variable**, not the function name (for named expressions).

---

2. **Immediately Invoked Function Expression (IIFE):**
   A function expression can run immediately after defining:

   ```javascript
   (function greet() {
       alert("Hello World");
   })();
   ```

---

3. **Return Statement:**
   Function expressions can return values like normal functions:

   ```javascript
   const mul = function(a, b) { return a * b; };
   let result = mul(4, 5); // 20
   ```

---

4. **Use as a Value:**
   The returned value from a function expression can be used in expressions:

   ```javascript
   const num = function() { return 2; };
   let result = num() * 3; // 6
   ```

---

5. **Nested Function Expressions:**
   You can define a function inside another function and call it:

   ```javascript
   const num = function() {
       const decimal = function() { return 5; };
       return decimal(); 
   };
   console.log(num()); // 5
   ```

---

‚úÖ **Key Points to Remember:**

* Function expressions can be **anonymous or named**.
* Use variable to **invoke the function**.
* Can be used as **IIFE, value, or nested function**.
* Helps in **keeping variables private** and avoiding global scope pollution.

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Great question! üëá
Let‚Äôs quickly understand what **`eval`** is ‚Äî because I mentioned it for comparison with `Function()`.

---

## ‚ö†Ô∏è What is `eval` in JavaScript

* `eval()` is a **built-in JavaScript function**.
* It takes a **string of JavaScript code** and **executes it immediately**.

---

### üìå Example

```javascript
const code = "2 + 3";
console.log(eval(code));  // 5
```

```javascript
eval("var x = 10; console.log(x);"); // 10
```

---

### ‚ö†Ô∏è Why it's risky

* `eval()` can **run any code**, even malicious code from user input.
* It makes debugging and performance worse.
* That‚Äôs why it‚Äôs considered **dangerous** and should be **avoided in real projects**.

---

### üìå Relation with `Function()` constructor

* Both `eval()` and `new Function()` **convert strings into executable code** at runtime.
* `new Function()` is **safer than `eval`** (it runs in global scope and has no access to local scope), but **still risky**.

---

### üß† Memory trick

> `eval("...")` ‚Üí **Evaluate this string now**
> `new Function("...")` ‚Üí **Make a new function from this string**

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## üß† JavaScript `Function()` Constructor ‚Äî Summary Notes

### üìå What it is

* `Function()` is a **built-in constructor** that creates **functions dynamically at runtime**.
* Syntax:

  ```js
  const fn = new Function(arg1, arg2, ..., functionBody);
  ```

  * All parameters are **strings**.
  * All arguments except the last are parameter names.
  * Last argument is the function body (code).

---

### üìå Key Points

* Functions created this way:

  * Always have **global scope** (not local).
  * Are created at **runtime (on the fly)**.
* Can be called **with or without `new`** keyword.
* ‚ö†Ô∏è **Use with caution** ‚Äî can cause **security issues** (like `eval`).

---

### üìå Examples

**With parameters**

```js
const mul = new Function("a", "b", "return a * b");
console.log(mul(5, 7));  // 35
```

**Without parameters**

```js
const sum = new Function("return 10 + 20");
console.log(sum()); // 30
```

**Return another function**

```js
const sayHello = new Function(
  "return function(name){ return `Hello, ${name}` }"
)();
console.log(sayHello("World")); // Hello, World
```

---

### üìå When to use

* When you need to **generate function code from strings at runtime** (very rare cases).
* Otherwise, prefer **normal function declarations / expressions** ‚Äî they are **faster and safer**.

---

### ‚ö° Memory Trick

> üß† `Function()` = like `eval` for functions
> üìù Use only when you must **build code from text dynamically**.

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Sure! üìù
Here‚Äôs a **very short and clear summary** of **JavaScript Hoisting** for quick notes:

---

## ‚ö° JavaScript Hoisting ‚Äî Quick Summary

* **Hoisting:** JS moves **declarations** (not values) to the **top of their scope** before code runs.

---

### üß© Function Hoisting

* ‚úÖ **Function Declarations** are hoisted
  ‚Üí You can call them before defining.

  ```js
  greet();
  function greet(){ console.log("Hi"); }
  ```

* ‚ùå **Function Expressions (let/const)** are **not hoisted**

  ```js
  greet(); // Error
  const greet = function(){};
  ```

---

### üì¶ Variable Hoisting

* ‚úÖ **var** is hoisted ‚Üí value becomes `undefined` until assigned

  ```js
  console.log(x); // undefined
  var x = 10;
  ```

* ‚ùå **let / const** are **not hoisted**

  ```js
  console.log(x); // Error
  let x = 10;
  ```

---

### üß† Key Points to Remember

* Only **declarations** are hoisted, **not initializations**.
* Works **within the same scope** (function/block).
* Best practice: **Always declare before using.**

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Sure! Here‚Äôs a **short and clear comparison**:

---

### **1Ô∏è‚É£ bind**

* Creates a **new function**.
* `this` is **permanently bound** to the given object.
* Arguments can be **pre-set** (partial application).
* **Does NOT execute immediately**.

```javascript
const person = {name: 'Alice'};
function greet(msg) { console.log(msg + ', ' + this.name); }
const greetAlice = greet.bind(person, 'Hello');
greetAlice(); // Hello, Alice
```

---

### **2Ô∏è‚É£ call**

* **Calls the function immediately**.
* First argument sets `this`.
* Other arguments are passed normally.

```javascript
const person = {name: 'Bob'};
function greet(msg) { console.log(msg + ', ' + this.name); }
greet.call(person, 'Hi'); // Hi, Bob
```

---

### **3Ô∏è‚É£ apply**

* Same as `call`, but **arguments are passed as an array**.

```javascript
const person = {name: 'Charlie'};
function greet(msg1, msg2) { console.log(msg1 + ' & ' + msg2 + ', ' + this.name); }
greet.apply(person, ['Hello', 'Hi']); // Hello & Hi, Charlie
```

---

‚úÖ **Quick memory tip:**

* `bind` ‚Üí returns a **function**
* `call` ‚Üí **calls immediately** with normal arguments
* `apply` ‚Üí **calls immediately** with arguments as **array**

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>


Sure! Let‚Äôs break **closures** in a very simple way.

---

## **Closure (Short Definition)**

A **closure** is when a function **remembers the variables from its outer scope**, even after the outer function has finished executing.

* In simple words: **A function ‚Äúcloses over‚Äù the variables it needs.**

---

### **Example 1: Simple Closure**

```javascript
function outer() {
  let name = 'Alice'; // outer variable

  function inner() {
    console.log('Hello, ' + name); // inner function uses outer variable
  }

  return inner;
}

const greet = outer(); // outer() runs and returns inner
greet(); // Hello, Alice
```

**Explanation:**

* `inner` still **remembers `name`**, even though `outer()` has finished.
* This is a **closure**.

---

### **Example 2: Counter with Closure**

```javascript
function counter() {
  let count = 0; // private variable

  return function() {
    count++;
    console.log(count);
  }
}

const myCounter = counter();
myCounter(); // 1
myCounter(); // 2
myCounter(); // 3
```

**Explanation:**

* Each time `myCounter()` is called, it **remembers `count`**.
* `count` is **protected** inside the closure ‚Äî other code cannot access it directly.

---

### **Key Points**

1. Closure = **function + remembered variables from outer scope**.
2. Useful for **data privacy** (like private variables).
3. Can **keep state** between function calls.

---

If you want, I can make a **super short, one-line memory trick** for closures like I did for `call/bind/apply`.

Do you want me to do that?

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
