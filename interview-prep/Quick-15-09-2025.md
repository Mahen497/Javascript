## ğŸ“ What is `??` ?
**Nullish Coalescing Operator (`??`)**:

> `a ?? b`
> returns **`a` if it is NOT null or undefined**,
> otherwise returns **`b`**.

It only checks for `null` or `undefined`, **not other falsy values** (like `0`, `false`, `""`).

---

```js
let x = (5 || 7) ?? 9;
let y = (5 && 7) ?? 9;

console.log(x);
console.log(y);
```

* `||` returns the **first truthy**
* `5` is truthy â†’ so result is `5`

* `5` is **not null/undefined** â†’ `??` keeps `5`

---

**First**: evaluate `(5 && 7)`

* `&&` returns the **second** if first is truthy
* `5` is truthy â†’ so result is `7`

* `7` is **not null/undefined** â†’ `??` keeps `7`

---

### âš¡ Memory Trick

* `||` â†’ picks **first truthy**
* `&&` â†’ picks **second if first is truthy**
* `??` â†’ picks **first unless it is null/undefined**

ğŸ§  Easy phrase:

> **â€œNullish (??) only cares about null/undefined â€” ignores false, 0, emptyâ€**


# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## ğŸ“ Grouping Operator

```js
let res1 = false && false || true;
console.log(res1);
```

---
### âš¡ Operator Precedence

* `&&` (AND) is evaluated **before** `||` (OR)

So this is treated as:

```js
let res1 = (false && false) || true;
```

ğŸ§  **Memory Trick**

> `&&` runs **before** `||` â€” think **"AND is stronger than OR"**
> So always group `&&` first when reading.

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

## ğŸ“ What is `yield`?

* The `yield` operator in JavaScript is used to pause and resume the generator function asynchronously
* `yield` is used **inside generator functions (`function*`)**
* It **pauses** the function and returns a value
* When you call `.next()` on the generator, it **resumes from where it paused**

---

### ğŸ“ Example

```js
function* myGenerator() {
  yield "Step 1";
  yield "Step 2";
  yield "Step 3";
}

const gen = myGenerator();

console.log(gen.next().value); // "Step 1"
console.log(gen.next().value); // "Step 2"
console.log(gen.next().value); // "Step 3"
console.log(gen.next().done);  // true (finished)
```

**How it works:**

* `yield` gives one value at a time
* After `yield`, the function is **paused**
* Next `.next()` call resumes from that exact spot

---

### ğŸ“‹ Key Points

| Keyword     | Purpose                          |
| ----------- | -------------------------------- |
| `function*` | defines a **generator** function |
| `yield`     | **pauses & returns** a value     |
| `.next()`   | **resumes** and gives next value |

---

### ğŸ§  Memory Trick

> Think of `yield` like **"pause and give"** ğŸ¬ğŸ¿
>
> * It **yields (hands over)** a value
> * Then **waits** until you ask for the next one

Or say in your head:

> **â€œyield = pause + return (until next call)â€**

---

## âš¡ Visual

```
function* â†’ like a TV series ğŸ“º
yield â†’ gives 1 episode, then pauses
next() â†’ plays the next episode
```

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>


## ğŸ“ **User-defined iterator** that gives **batches of numbers** from `start` to `end`.

---

## âš™ï¸ Code

```js
function makeRange(start, end, batchSize) {
  return {
    [Symbol.iterator]() {
      let current = start;

      return {
        next() {
          if (current > end) return { done: true };

          const batch = [];
          for (let i = 0; i < batchSize && current <= end; i++) {
            batch.push(current++);
          }

          return { value: batch, done: false };
        }
      };
    }
  };
}

// âœ… Usage
for (let batch of makeRange(1, 50, 10)) {
  console.log(batch);
}
```

---

## âš¡ Output

```
[1,2,3,4,5,6,7,8,9,10]
[11,12,13,14,15,16,17,18,19,20]
...
```

---

## ğŸ§  Memory Trick

> `makeRange(start, end, size)`
> \= **â€œGive me boxes of numbers, each of size `size`â€** ğŸ“¦

---

