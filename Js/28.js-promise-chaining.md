
# 🔗 JavaScript – Promise Chaining

### ✅ What is it?

Promise chaining means using **`.then()` one after another**, where the **output of one Promise becomes the input of the next**.

---

### 📌 Example:

```js
let promise = new Promise((resolve, reject) => {
  resolve(2);
});

promise
  .then(num => {
    console.log("First then:", num);   // 2
    return num * 2;                    // Pass 4 to next
  })
  .then(num => {
    console.log("Second then:", num);  // 4
    return num * 3;                    // Pass 12
  })
  .then(num => {
    console.log("Third then:", num);   // 12
  })
  .catch(err => console.log("Error:", err));
```

---

### 🧠 Memory Trick

Think of Promises like a **domino chain** 🎲:
➡️ First `.then()` knocks the next
➡️ The next gets the result & continues
➡️ If one fails, `.catch()` handles it 🚑

---

### ✅ Why use it?

* To **avoid callback hell** 😵
* Run tasks **step by step** (sequentially).
* Handle errors **in one place** with `.catch()`.

---

👉 Real-life analogy:
1️⃣ Order food 🍔
2️⃣ After it arrives, eat it 🍽️
3️⃣ After eating, pay the bill 💳
Each step depends on the **previous one** = Promise Chaining.

---

```js
let output = document.getElementById("output");
  function fetchData() {
      fetch('https://jsonplaceholder.typicode.com/todos/1')
      .then(response => response.json()) // Promise chaining
      .then((data) => {
        output.innerHTML += "The data is - " + JSON.stringify(data);
      })
  }

```

```js
async function fetchData() {
  try {
    const res = await fetch('https://jsonplaceholder.typicode.com/todos/1');
    const data = await res.json();   // ✅ await added
    console.log(data);
  } catch (err) {
    console.error("Error:", err);   // ✅ log errors
  }
}

fetchData();
```

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Nice 👍 Let’s break down **`Promise.all`** vs **`Promise.allSettled`** in an interview-ready way.

---

## 🔹 `Promise.all`

* Takes an **array of Promises**.
* Returns a **single Promise** that:

  * ✅ Resolves → when **all Promises succeed**, giving an array of results.
  * ❌ Rejects → if **any Promise fails** (short-circuits).

```js
const p1 = Promise.resolve("✅ P1");
const p2 = Promise.resolve("✅ P2");
const p3 = Promise.reject("❌ P3");

Promise.all([p1, p2])
  .then(results => console.log("All Success:", results))
  .catch(err => console.log("Error:", err));

Promise.all([p1, p2, p3])
  .then(results => console.log(results))
  .catch(err => console.log("Error:", err)); // ❌ P3
```

👉 Use when: You need **all Promises to succeed** (e.g., load multiple APIs before rendering).

---

## 🔹 `Promise.allSettled`

* Takes an **array of Promises**.
* Returns a **single Promise** that resolves **always**, when all Promises settle (fulfilled or rejected).
* Gives back an array of objects with `{status, value}` or `{status, reason}`.

```js
const p1 = Promise.resolve("✅ P1");
const p2 = Promise.reject("❌ P2");

Promise.allSettled([p1, p2]).then(results => console.log(results));
```

**Output:**

```js
[
  { status: "fulfilled", value: "✅ P1" },
  { status: "rejected", reason: "❌ P2" }
]
```

👉 Use when: You need **results of all operations**, even if some fail (e.g., fetch from multiple APIs and log which worked/failed).

---

## 🔑 Interview One-Liner

* **`Promise.all`** → resolves only if all succeed; rejects on the first failure.
* **`Promise.allSettled`** → waits for all, and always resolves with an array of result statuses.

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>


``js

const p1 = new Promise(res => setTimeout(() => res("✅ P1"), 1000));
const p2 = new Promise((_, rej) => setTimeout(() => rej("❌ P2"), 2000));
const p3 = new Promise(res => setTimeout(() => res("✅ P3"), 3000));

// Promise.all → waits for all (fails if any rejects)
Promise.all([p1, p3])
  .then(results => console.log("All:", results))
  .catch(err => console.log("All Error:", err));

// Promise.allSettled → waits for all, always resolves
Promise.allSettled([p1, p2, p3])
  .then(results => console.log("AllSettled:", results));

// Promise.race → first one wins (resolve or reject)
Promise.race([p1, p2, p3])
  .then(result => console.log("Race:", result))
  .catch(err => console.log("Race Error:", err));

// Promise.any → first success wins (ignore rejects)
Promise.any([p2, p3])
  .then(result => console.log("Any:", result))
  .catch(err => console.log("Any Error:", err));

```


🔹 Interview Mnemonics

all → "all must pass"
allSettled → "tell me everything"
race → "first to finish wins, good or bad"
any → "first success wins"