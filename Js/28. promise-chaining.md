
# ğŸ”— JavaScript â€“ Promise Chaining

### âœ… What is it?

Promise chaining means using **`.then()` one after another**, where the **output of one Promise becomes the input of the next**.

---

### ğŸ“Œ Example:

```js
let promise = new Promise((resolve, reject) => {
  resolve(2);
});

promise
  .then(num => {
    console.log("First then:", num);   // 2
    return num * 2;                    // Pass 4 to next
  })
  .then(num => {
    console.log("Second then:", num);  // 4
    return num * 3;                    // Pass 12
  })
  .then(num => {
    console.log("Third then:", num);   // 12
  })
  .catch(err => console.log("Error:", err));
```

---

### ğŸ§  Memory Trick

Think of Promises like a **domino chain** ğŸ²:
â¡ï¸ First `.then()` knocks the next
â¡ï¸ The next gets the result & continues
â¡ï¸ If one fails, `.catch()` handles it ğŸš‘

---

### âœ… Why use it?

* To **avoid callback hell** ğŸ˜µ
* Run tasks **step by step** (sequentially).
* Handle errors **in one place** with `.catch()`.

---

ğŸ‘‰ Real-life analogy:
1ï¸âƒ£ Order food ğŸ”
2ï¸âƒ£ After it arrives, eat it ğŸ½ï¸
3ï¸âƒ£ After eating, pay the bill ğŸ’³
Each step depends on the **previous one** = Promise Chaining.

---

```js
let output = document.getElementById("output");
  function fetchData() {
      fetch('https://jsonplaceholder.typicode.com/todos/1')
      .then(response => response.json()) // Promise chaining
      .then((data) => {
        output.innerHTML += "The data is - " + JSON.stringify(data);
      })
  }

```

```js
async function fetchData() {
  try {
    const res = await fetch('https://jsonplaceholder.typicode.com/todos/1');
    const data = await res.json();   // âœ… await added
    console.log(data);
  } catch (err) {
    console.error("Error:", err);   // âœ… log errors
  }
}

fetchData();
```

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

Nice ğŸ‘ Letâ€™s break down **`Promise.all`** vs **`Promise.allSettled`** in an interview-ready way.

---

## ğŸ”¹ `Promise.all`

* Takes an **array of Promises**.
* Returns a **single Promise** that:

  * âœ… Resolves â†’ when **all Promises succeed**, giving an array of results.
  * âŒ Rejects â†’ if **any Promise fails** (short-circuits).

```js
const p1 = Promise.resolve("âœ… P1");
const p2 = Promise.resolve("âœ… P2");
const p3 = Promise.reject("âŒ P3");

Promise.all([p1, p2])
  .then(results => console.log("All Success:", results))
  .catch(err => console.log("Error:", err));

Promise.all([p1, p2, p3])
  .then(results => console.log(results))
  .catch(err => console.log("Error:", err)); // âŒ P3
```

ğŸ‘‰ Use when: You need **all Promises to succeed** (e.g., load multiple APIs before rendering).

---

## ğŸ”¹ `Promise.allSettled`

* Takes an **array of Promises**.
* Returns a **single Promise** that resolves **always**, when all Promises settle (fulfilled or rejected).
* Gives back an array of objects with `{status, value}` or `{status, reason}`.

```js
const p1 = Promise.resolve("âœ… P1");
const p2 = Promise.reject("âŒ P2");

Promise.allSettled([p1, p2]).then(results => console.log(results));
```

**Output:**

```js
[
  { status: "fulfilled", value: "âœ… P1" },
  { status: "rejected", reason: "âŒ P2" }
]
```

ğŸ‘‰ Use when: You need **results of all operations**, even if some fail (e.g., fetch from multiple APIs and log which worked/failed).

---

## ğŸ”‘ Interview One-Liner

* **`Promise.all`** â†’ resolves only if all succeed; rejects on the first failure.
* **`Promise.allSettled`** â†’ waits for all, and always resolves with an array of result statuses.

---

# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>


``js

const p1 = new Promise(res => setTimeout(() => res("âœ… P1"), 1000));
const p2 = new Promise((_, rej) => setTimeout(() => rej("âŒ P2"), 2000));
const p3 = new Promise(res => setTimeout(() => res("âœ… P3"), 3000));

// Promise.all â†’ waits for all (fails if any rejects)
Promise.all([p1, p3])
  .then(results => console.log("All:", results))
  .catch(err => console.log("All Error:", err));

// Promise.allSettled â†’ waits for all, always resolves
Promise.allSettled([p1, p2, p3])
  .then(results => console.log("AllSettled:", results));

// Promise.race â†’ first one wins (resolve or reject)
Promise.race([p1, p2, p3])
  .then(result => console.log("Race:", result))
  .catch(err => console.log("Race Error:", err));

// Promise.any â†’ first success wins (ignore rejects)
Promise.any([p2, p3])
  .then(result => console.log("Any:", result))
  .catch(err => console.log("Any Error:", err));

```


ğŸ”¹ Interview Mnemonics

all â†’ "all must pass"
allSettled â†’ "tell me everything"
race â†’ "first to finish wins, good or bad"
any â†’ "first success wins"